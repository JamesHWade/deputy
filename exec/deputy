#!/usr/bin/env Rapp
#| title: deputy
#| description: Interactive AI agent CLI for R

# Provider configuration
#| description: LLM provider to use (anthropic, openai, google, ollama)
#| short: p
provider <- "anthropic"

#| description: Model to use (provider-specific, e.g., claude-sonnet-4-5-20250929, gpt-4o, gemini-2.0-flash)
#| short: m
model <- NA_character_

# Tool configuration
#| description: Tool preset (minimal, standard, dev, data, full)
#| short: t
tools <- "standard"

# Permission configuration
#| description: Permission mode (standard, readonly, full)
#| short: P
permissions <- "standard"

#| description: Maximum number of turns before stopping
#| short: n
max_turns <- 25L

#| description: Maximum cost in USD before stopping
#| short: c
max_cost <- NA_real_

# Session management
#| description: Path to session file to load/resume
#| short: s
session <- NA_character_

#| description: Path to save session on exit
#| short: S
save_session <- NA_character_

# System prompt
#| description: Custom system prompt to use
#| short: y
system_prompt <- NA_character_

#| description: Path to file containing system prompt
#| short: f
system_prompt_file <- NA_character_

# Human-in-the-loop
#| description: Disable ask_user tool (human-in-the-loop questions)
#| short: A
no_ask <- FALSE

# MCP (Model Context Protocol) servers
#| description: Enable MCP server tools from config
#| short: M
mcp <- FALSE

#| description: Path to MCP config file (default: ~/.config/mcptools/config.json)
#| short: C
mcp_config <- NA_character_

#| description: MCP server name to load (repeatable; default: all)
mcp_server <- c()

#| description: [Deprecated] Comma-separated list of MCP server names to load (default: all)
mcp_servers <- NA_character_

# Claude settings
#| description: Claude setting source (repeatable: project, user, or settings.json path)
setting_source <- c()

# Working directory
#| description: Working directory for file operations
#| short: d
dir <- getwd()

# Output options
#| description: Show verbose output including tool calls
#| short: v
verbose <- FALSE

#| description: Disable colored output
no_color <- FALSE

#| description: Enable debug logging for CLI diagnostics
#| short: g
debug <- FALSE

#| description: Path to write debug logs (enables debug mode automatically)
#| short: G
debug_file <- NA_character_

# Single task mode
#| description: Run a single task and exit (non-interactive)
#| required: false
#| short: x
task <- NULL

# --- Main application ---

library(deputy)

# Rapp 0.3: NULL assignments are positional by default; use typed NAs for
# optional flags and normalize them back to NULL before runtime logic.
null_if_na <- function(x) {
  if (is.null(x)) {
    return(NULL)
  }
  if (length(x) == 1 && is.atomic(x) && is.na(x)) {
    return(NULL)
  }
  x
}

split_csv_values <- function(values) {
  if (is.null(values) || length(values) == 0) {
    return(character())
  }
  if (is.list(values)) {
    values <- unlist(values, recursive = TRUE, use.names = FALSE)
  }
  values <- as.character(values)
  parts <- unlist(strsplit(values, ",", fixed = TRUE), use.names = FALSE)
  parts <- trimws(parts)
  parts[nzchar(parts)]
}

model <- null_if_na(model)
max_cost <- null_if_na(max_cost)
session <- null_if_na(session)
save_session <- null_if_na(save_session)
system_prompt <- null_if_na(system_prompt)
system_prompt_file <- null_if_na(system_prompt_file)
mcp_config <- null_if_na(mcp_config)
mcp_servers <- null_if_na(mcp_servers)
debug_file <- null_if_na(debug_file)

create_debug_logger <- function(enabled = FALSE, path = NULL) {
  if (!enabled) {
    return(structure(
      function(...) invisible(NULL),
      close = function() invisible(NULL)
    ))
  }

  con <- NULL
  if (!is.null(path)) {
    con <- file(path, open = "a")
  }

  logger <- function(...) {
    msg <- paste(..., collapse = "")
    line <- paste0(
      format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
      " [deputy-debug] ",
      msg
    )
    if (is.null(con)) {
      cat(line, "\n", file = stderr())
    } else {
      writeLines(line, con = con)
      flush(con)
    }
    invisible(NULL)
  }

  attr(logger, "close") <- function() {
    if (!is.null(con)) {
      close(con)
    }
    invisible(NULL)
  }

  logger
}

# Handle color setting
if (no_color) {
  options(cli.num_colors = 1)
}

# Create chat object based on provider
# Returns an ellmer chat object configured for the specified provider
create_chat <- function(provider, model) {
  known_providers <- c("anthropic", "openai", "google", "ollama")

  # Warn about unknown providers

  if (!provider %in% known_providers) {
    cli::cli_warn(c(
      "Unknown provider {.val {provider}}",
      "i" = "Known providers: {.val {known_providers}}",
      "i" = "Attempting generic chat interface..."
    ))
  }

  # Set default models per provider if not specified
  if (is.null(model)) {
    model <- switch(provider,
      anthropic = "claude-sonnet-4-5-20250929",
      openai = "gpt-4o",
      google = "gemini-2.0-flash",
      ollama = "llama3.2",
      "default"
    )
  }

  chat <- switch(provider,
    anthropic = ellmer::chat_anthropic(model = model),
    openai = ellmer::chat_openai(model = model),
    google = ellmer::chat_google(model = model),
    ollama = ellmer::chat_ollama(model = model),
    # Try generic chat() for other providers
    ellmer::chat(paste0(provider, "/", model))
  )

  chat
}

# Get tools based on preset
get_tools <- function(preset, include_ask = TRUE) {
  base_tools <- tools_preset(preset)
  if (include_ask) {
    c(base_tools, list(tool_ask_user))
  } else {
    base_tools
  }
}

# Get permissions based on mode
# Pass max_turns and max_cost during construction (Permissions are immutable after creation)
get_permissions <- function(mode, working_dir, max_turns = 25L, max_cost = NULL) {
  switch(mode,
    standard = permissions_standard(working_dir, max_turns = max_turns, max_cost_usd = max_cost),
    readonly = permissions_readonly(max_turns = max_turns),
    full = permissions_full(max_turns = max_turns, max_cost_usd = max_cost),
    permissions_standard(working_dir, max_turns = max_turns, max_cost_usd = max_cost)
  )
}

# Read system prompt from file if specified
get_system_prompt <- function(system_prompt, system_prompt_file) {
  if (!is.null(system_prompt_file)) {
    if (!file.exists(system_prompt_file)) {
      cli::cli_abort("System prompt file not found: {.path {system_prompt_file}}")
    }
    return(paste(readLines(system_prompt_file, warn = FALSE), collapse = "\n"))
  }
  system_prompt
}

# Format cost for display
format_cost <- function(cost) {
  if (is.null(cost) || is.na(cost$total) || cost$total == 0) {
    return("")
  }
  sprintf(" ($%.4f)", cost$total)
}

# Print welcome message
print_welcome <- function(agent, provider, model_name, tools_preset, perm_mode) {
  provider_info <- agent$provider()
  mcp_tools <- agent$mcp_tools()

  cli::cli_h1("deputy")
  cli::cli_text("Interactive AI Agent for R")
  cli::cli_text("")

  bullets <- c(
    "*" = "Provider: {.val {provider_info$name}}",
    "*" = "Model: {.val {provider_info$model}}",
    "*" = "Tools: {.val {tools_preset}}",
    "*" = "Permissions: {.val {perm_mode}}",
    "*" = "Working dir: {.path {agent$working_dir}}"
  )

  # Add MCP info if tools are loaded

  if (length(mcp_tools) > 0) {
    bullets <- c(bullets, "*" = "MCP tools: {.val {length(mcp_tools)}}")
  }

  cli::cli_bullets(bullets)
  cli::cli_text("")
  cli::cli_alert_info("Type your message and press Enter. Type {.kbd /help} for commands.")
  cli::cli_text("")
}

# Process special commands
process_command <- function(input, agent) {
  if (!startsWith(input, "/")) {
    return(list(is_command = FALSE))
  }

  parts <- strsplit(trimws(input), "\\s+")[[1]]
  cmd <- tolower(parts[1])
  args <- parts[-1]


  switch(cmd,
    "/quit" = ,
    "/exit" = ,
    "/q" = {
      return(list(is_command = TRUE, action = "quit"))
    },

    "/save" = {
      if (length(args) == 0) {
        path <- paste0("deputy_session_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".rds")
      } else {
        path <- args[1]
      }
      tryCatch(
        {
          agent$save_session(path)
          cli::cli_alert_success("Session saved to {.path {path}}")
        },
        error = function(e) {
          cli::cli_alert_danger("Failed to save session: {e$message}")
          cli::cli_alert_info("Check the path is writable: {.path {path}}")
        }
      )
      return(list(is_command = TRUE, action = "continue"))
    },

    "/clear" = {
      agent$chat$set_turns(list())
      cli::cli_alert_success("Conversation cleared")
      return(list(is_command = TRUE, action = "continue"))
    },

    "/compact" = {
      keep <- 4L
      if (length(args) > 0) {
        parsed <- suppressWarnings(as.integer(args[1]))
        if (is.na(parsed) || parsed < 1) {
          cli::cli_alert_warning("Invalid keep value: {.val {args[1]}}. Using default (4)")
        } else {
          keep <- parsed
        }
      }
      tryCatch(
        {
          agent$compact(keep_last = keep)
          cli::cli_alert_success("Conversation compacted (kept {.val {keep}} recent turns)")
        },
        error = function(e) {
          cli::cli_alert_danger("Compaction failed: {e$message}")
        }
      )
      return(list(is_command = TRUE, action = "continue"))
    },

    "/cost" = {
      cost <- agent$cost()
      cli::cli_h3("Cost Summary")
      cli::cli_bullets(c(
        "*" = "Input tokens: {.val {cost$input}}",
        "*" = "Output tokens: {.val {cost$output}}",
        "*" = "Cached tokens: {.val {cost$cached}}",
        "*" = "Total cost: {.val {sprintf('$%.4f', cost$total)}}"
      ))
      return(list(is_command = TRUE, action = "continue"))
    },

    "/turns" = {
      turns <- agent$turns()
      cli::cli_alert_info("Conversation has {.val {length(turns)}} turns")
      return(list(is_command = TRUE, action = "continue"))
    },

    "/help" = {
      cli::cli_h3("Available Commands")
      cli::cli_bullets(c(
        "*" = "{.kbd /quit} or {.kbd /exit} - Exit the CLI",
        "*" = "{.kbd /save [path]} - Save session (default: deputy_session_<timestamp>.rds)",
        "*" = "{.kbd /clear} - Clear conversation history",
        "*" = "{.kbd /compact [n]} - Compact conversation, keep n recent turns (default: 4)",
        "*" = "{.kbd /cost} - Show cost summary",
        "*" = "{.kbd /turns} - Show turn count",
        "*" = "{.kbd /help} - Show this help"
      ))
      return(list(is_command = TRUE, action = "continue"))
    },

    {
      cli::cli_alert_warning("Unknown command: {.val {cmd}}. Type {.kbd /help} for available commands.")
      return(list(is_command = TRUE, action = "continue"))
    }
  )
}

# Run a single task (non-interactive mode)
run_task <- function(agent, task_text, verbose, debug_log = NULL) {
  cli::cli_alert_info("Running task: {.val {task_text}}")
  cli::cli_text("")
  if (!is.null(debug_log)) {
    debug_log("run_task started")
  }

  for (event in agent$run(task_text)) {
    switch(event$type,
      "text" = {
        cat(event$text)
      },
      "tool_start" = {
        if (!is.null(debug_log)) {
          tool_name <- if (is.null(event$tool_name)) "<unknown>" else event$tool_name
          debug_log("tool_start: ", tool_name)
        }
        if (verbose) {
          cli::cli_alert_info("Tool: {.fn {event$tool_name}}")
        }
      },
      "tool_end" = {
        if (!is.null(debug_log)) {
          tool_name <- if (is.null(event$tool_name)) "<unknown>" else event$tool_name
          if (!is.null(event$error)) {
            debug_log("tool_end error: ", tool_name, " -> ", event$error)
          } else {
            debug_log("tool_end success: ", tool_name)
          }
        }
        # Always show tool errors, not just in verbose mode
        if (!is.null(event$error)) {
          cli::cli_alert_danger("Tool {.fn {event$tool_name}} failed: {event$error}")
        } else if (verbose) {
          cli::cli_alert_success("Done: {.fn {event$tool_name}}")
        }
      },
      "stop" = {
        if (!is.null(debug_log)) {
          turns <- if (is.null(event$total_turns)) "NA" else as.character(event$total_turns)
          debug_log("run_task stop: turns=", turns)
        }
        cat("\n")
        cost <- event$cost
        if (!is.null(cost) && !is.na(cost$total) && cost$total > 0) {
          cli::cli_alert_info("Cost: {.val {sprintf('$%.4f', cost$total)}}")
        }
        cli::cli_alert_success("Completed in {.val {event$total_turns}} turn(s)")
      }
    )
  }
}

# Interactive chat loop
run_interactive <- function(agent, verbose, debug_log = NULL) {
  if (!is.null(debug_log)) {
    debug_log("run_interactive started")
  }
  repeat {
    # Read user input with improved error handling
    input <- tryCatch(
      readline(prompt = cli::col_cyan("> ")),
      error = function(e) {
        # Check for EOF-like errors
        if (grepl("EOF|end of file|connection", e$message, ignore.case = TRUE)) {
          return(NULL)
        }
        # Log unexpected errors before treating as exit
        cli::cli_alert_warning("Input error: {e$message}")
        return(NULL)
      }
    )

    # Handle EOF or input error
    if (is.null(input)) {
      cli::cli_text("")
      cli::cli_alert_info("Goodbye!")
      break
    }

    # Skip empty input
    input <- trimws(input)
    if (nchar(input) == 0) {
      next
    }

    # Process commands
    cmd_result <- process_command(input, agent)
    if (cmd_result$is_command) {
      if (!is.null(debug_log)) {
        debug_log("command: ", input)
      }
      if (identical(cmd_result$action, "quit")) {
        cli::cli_alert_info("Goodbye!")
        break
      }
      next
    }

    # Run the agent
    cli::cli_text("")
    for (event in agent$run(input)) {
      switch(event$type,
        "text" = {
          cat(event$text)
        },
        "tool_start" = {
          if (!is.null(debug_log)) {
            tool_name <- if (is.null(event$tool_name)) "<unknown>" else event$tool_name
            debug_log("tool_start: ", tool_name)
          }
          if (verbose) {
            cli::cli_alert_info("Calling: {.fn {event$tool_name}}")
          }
        },
        "tool_end" = {
          if (!is.null(debug_log)) {
            tool_name <- if (is.null(event$tool_name)) "<unknown>" else event$tool_name
            if (!is.null(event$error)) {
              debug_log("tool_end error: ", tool_name, " -> ", event$error)
            } else {
              debug_log("tool_end success: ", tool_name)
            }
          }
          # Always show tool errors, not just in verbose mode
          if (!is.null(event$error)) {
            cli::cli_alert_danger("Tool {.fn {event$tool_name}} failed: {event$error}")
          } else if (verbose) {
            cli::cli_alert_success("Done: {.fn {event$tool_name}}")
          }
        },
        "stop" = {
          cat("\n")
          cost <- event$cost
          if (verbose && !is.null(cost) && !is.na(cost$total) && cost$total > 0) {
            cli::cli_text(cli::col_grey(sprintf("[%d turns, $%.4f]", event$total_turns, cost$total)))
          }
        }
      )
    }
    cli::cli_text("")
  }
}

# --- Main execution ---
debug_enabled <- isTRUE(debug) || !is.null(debug_file)
debug_log <- create_debug_logger(enabled = debug_enabled, path = debug_file)
on.exit(attr(debug_log, "close")(), add = TRUE)
if (debug_enabled) {
  debug_log("Debug mode enabled")
}

# Create chat object (wrap in tryCatch for credential errors)
chat <- tryCatch(
  create_chat(provider, model),
  error = function(e) {
    cli::cli_abort(c(
      "Failed to connect to provider",
      "x" = e$message,
      "i" = "Check your provider credentials and configuration"
    ))
  }
)
if (debug_enabled) {
  model_name <- if (is.null(model)) "<default>" else model
  debug_log("Chat initialized for provider=", provider, " model=", model_name)
}

# Build components
agent_tools <- get_tools(tools, include_ask = !no_ask)
agent_permissions <- get_permissions(permissions, dir, max_turns = max_turns, max_cost = max_cost)
sys_prompt <- get_system_prompt(system_prompt, system_prompt_file)
setting_sources <- unique(split_csv_values(setting_source))
if (length(setting_sources) == 0) {
  setting_sources <- NULL
}
if (debug_enabled && !is.null(setting_sources)) {
  debug_log("Setting sources: ", paste(setting_sources, collapse = ","))
}

# Create agent
agent <- Agent$new(
  chat = chat,
  tools = agent_tools,
  system_prompt = sys_prompt,
  permissions = agent_permissions,
  working_dir = dir,
  setting_sources = setting_sources
)
if (debug_enabled) {
  debug_log("Agent created with tool preset=", tools, " and permission mode=", permissions)
}

# Load MCP tools if enabled
if (mcp) {
  servers_repeatable <- split_csv_values(mcp_server)
  servers_legacy <- split_csv_values(mcp_servers)
  if (length(servers_legacy) > 0) {
    cli::cli_warn(c(
      "{.arg --mcp-servers} is deprecated",
      "i" = "Use repeated {.arg --mcp-server} instead"
    ))
  }
  servers_list <- unique(c(servers_repeatable, servers_legacy))
  if (length(servers_list) == 0) {
    servers_list <- NULL
  }
  if (debug_enabled) {
    debug_log(
      "Loading MCP tools with servers=",
      if (is.null(servers_list)) "<all>" else paste(servers_list, collapse = ",")
    )
  }
  agent$load_mcp(config = mcp_config, servers = servers_list)
}

# Load session if specified
if (!is.null(session)) {
  if (!file.exists(session)) {
    cli::cli_abort("Session file not found: {.path {session}}")
  }
  agent$load_session(session)
}

# Run in appropriate mode
if (!is.null(task)) {
  # Single task mode
  run_task(agent, task, verbose, debug_log = if (debug_enabled) debug_log else NULL)
} else {
  # Interactive mode
  print_welcome(agent, provider, model, tools, permissions)
  run_interactive(agent, verbose, debug_log = if (debug_enabled) debug_log else NULL)
}

# Save session on exit if specified
if (!is.null(save_session)) {
  agent$save_session(save_session)
}
