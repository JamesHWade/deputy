% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agent.R
\name{Agent}
\alias{Agent}
\title{Agent R6 Class}
\description{
The main class for creating AI agents that can use tools to accomplish tasks.
Agent wraps an ellmer Chat object and adds agentic capabilities including
multi-turn execution, permission enforcement, and streaming output.
}
\section{Skill Methods}{

The following methods manage skills:

\describe{
\item{\verb{$load_skill(skill, allow_conflicts = FALSE)}}{Load a \link{Skill} into
the agent. The \code{skill} parameter can be a Skill object or path to a
skill directory. If \code{allow_conflicts} is FALSE (default), an error is
thrown when skill tools conflict with existing tools. Set to TRUE to
allow overwriting. Returns invisible self.}
\item{\verb{$skills()}}{Get a named list of loaded \link{Skill} objects.}
}
}

\section{MCP Methods}{

The following methods manage MCP (Model Context Protocol) server tools:

\describe{
\item{\verb{$load_mcp(config = NULL, servers = NULL)}}{Load tools from MCP
servers. The \code{config} parameter specifies the path to the MCP config
file (defaults to \verb{~/.config/mcptools/config.json}). The \code{servers}
parameter optionally filters to specific server names. Requires the
mcptools package. Returns invisible self.}
\item{\verb{$mcp_tools()}}{Get names of loaded MCP tools.}
}
}

\examples{
\dontrun{
# Create an agent with file tools
agent <- Agent$new(
  chat = ellmer::chat("openai/gpt-4o"),
  tools = tools_file()
)

# Run a task with streaming output
for (event in agent$run("List files in the current directory")) {
  if (event$type == "text") cat(event$text)
}

# Or use the blocking convenience method
result <- agent$run_sync("List files")
print(result$response)
}

## ------------------------------------------------
## Method `Agent$add_hook`
## ------------------------------------------------

\dontrun{
# Add a hook to block dangerous bash commands
agent$add_hook(hook_block_dangerous_bash())

# Add a custom PreToolUse hook
agent$add_hook(HookMatcher$new(
  event = "PreToolUse",
  pattern = "^write_file$",
  callback = function(tool_name, tool_input, context) {
    cli::cli_alert_info("Writing to: {tool_input$path}")
    HookResultPreToolUse(permission = "allow")
  }
))
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{chat}}{The wrapped ellmer Chat object}

\item{\code{permissions}}{Permission policy for the agent}

\item{\code{working_dir}}{Working directory for file operations}

\item{\code{hooks}}{Hook registry for lifecycle events}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Agent-new}{\code{Agent$new()}}
\item \href{#method-Agent-run}{\code{Agent$run()}}
\item \href{#method-Agent-run_sync}{\code{Agent$run_sync()}}
\item \href{#method-Agent-register_tool}{\code{Agent$register_tool()}}
\item \href{#method-Agent-register_tools}{\code{Agent$register_tools()}}
\item \href{#method-Agent-add_hook}{\code{Agent$add_hook()}}
\item \href{#method-Agent-turns}{\code{Agent$turns()}}
\item \href{#method-Agent-last_turn}{\code{Agent$last_turn()}}
\item \href{#method-Agent-cost}{\code{Agent$cost()}}
\item \href{#method-Agent-provider}{\code{Agent$provider()}}
\item \href{#method-Agent-save_session}{\code{Agent$save_session()}}
\item \href{#method-Agent-load_session}{\code{Agent$load_session()}}
\item \href{#method-Agent-compact}{\code{Agent$compact()}}
\item \href{#method-Agent-print}{\code{Agent$print()}}
\item \href{#method-Agent-load_skill}{\code{Agent$load_skill()}}
\item \href{#method-Agent-skills}{\code{Agent$skills()}}
\item \href{#method-Agent-slash_commands}{\code{Agent$slash_commands()}}
\item \href{#method-Agent-settings}{\code{Agent$settings()}}
\item \href{#method-Agent-load_mcp}{\code{Agent$load_mcp()}}
\item \href{#method-Agent-mcp_tools}{\code{Agent$mcp_tools()}}
\item \href{#method-Agent-run_shiny}{\code{Agent$run_shiny()}}
\item \href{#method-Agent-clone}{\code{Agent$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-new"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-new}{}}}
\subsection{Method \code{new()}}{
Create a new Agent.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$new(
  chat,
  tools = list(),
  system_prompt = NULL,
  permissions = NULL,
  working_dir = getwd(),
  setting_sources = NULL,
  settings = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{chat}}{An ellmer Chat object created by \code{ellmer::chat()} or
provider-specific functions like \code{ellmer::chat_openai()}.}

\item{\code{tools}}{A list of tools created with \code{ellmer::tool()}. See
\code{\link[=tools_file]{tools_file()}} and \code{\link[=tools_code]{tools_code()}} for built-in tool bundles.}

\item{\code{system_prompt}}{Optional system prompt. If provided, overrides the
chat object's existing system prompt.}

\item{\code{permissions}}{A \link{Permissions} object controlling what the agent can do.
Defaults to \code{\link[=permissions_standard]{permissions_standard()}}.}

\item{\code{working_dir}}{Working directory for file operations. Defaults to
current directory.}

\item{\code{setting_sources}}{Optional character vector of Claude-style
setting sources (e.g., "project", "user") used to load memory, skills,
and slash commands.}

\item{\code{settings}}{Optional pre-loaded settings list from
\code{\link[=claude_settings_load]{claude_settings_load()}}. If provided, bypasses \code{setting_sources}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{Agent} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-run"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-run}{}}}
\subsection{Method \code{run()}}{
Run an agentic task with streaming output.

Returns a generator that yields \link{AgentEvent} objects as the agent works.
The agent will continue until the task is complete, max_turns is reached,
or the cost limit is exceeded.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$run(
  task,
  max_turns = NULL,
  include_partial_messages = TRUE,
  output_format = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task}}{The task for the agent to perform}

\item{\code{max_turns}}{Maximum number of turns (default: from permissions)}

\item{\code{include_partial_messages}}{If TRUE (default), yield partial text
chunks as they stream. If FALSE, only yield \code{text_complete}.}

\item{\code{output_format}}{Optional output format spec (e.g. JSON schema) to
guide and validate structured responses.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A generator yielding \link{AgentEvent} objects
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-run_sync"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-run_sync}{}}}
\subsection{Method \code{run_sync()}}{
Run an agentic task and block until completion.

Convenience wrapper around \code{run()} that collects all events and returns
an \link{AgentResult}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$run_sync(
  task,
  max_turns = NULL,
  include_partial_messages = TRUE,
  output_format = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task}}{The task for the agent to perform}

\item{\code{max_turns}}{Maximum number of turns (default: from permissions)}

\item{\code{include_partial_messages}}{If TRUE (default), keep partial text
events. If FALSE, suppress partials.}

\item{\code{output_format}}{Optional output format spec (e.g. JSON schema) to
guide and validate structured responses.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \link{AgentResult} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-register_tool"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-register_tool}{}}}
\subsection{Method \code{register_tool()}}{
Register a tool with the agent.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$register_tool(tool)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tool}}{A tool created with \code{ellmer::tool()}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible self for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-register_tools"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-register_tools}{}}}
\subsection{Method \code{register_tools()}}{
Register multiple tools with the agent.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$register_tools(tools)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tools}}{A list of tools created with \code{ellmer::tool()}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible self for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-add_hook"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-add_hook}{}}}
\subsection{Method \code{add_hook()}}{
Add a hook to the agent.

Hooks are called at specific points during agent execution and can
modify behavior (e.g., deny tool calls, log events).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$add_hook(hook)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{hook}}{A \link{HookMatcher} object}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible self for chaining
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
# Add a hook to block dangerous bash commands
agent$add_hook(hook_block_dangerous_bash())

# Add a custom PreToolUse hook
agent$add_hook(HookMatcher$new(
  event = "PreToolUse",
  pattern = "^write_file$",
  callback = function(tool_name, tool_input, context) {
    cli::cli_alert_info("Writing to: {tool_input$path}")
    HookResultPreToolUse(permission = "allow")
  }
))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-turns"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-turns}{}}}
\subsection{Method \code{turns()}}{
Get the conversation history.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$turns()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of Turn objects
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-last_turn"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-last_turn}{}}}
\subsection{Method \code{last_turn()}}{
Get the last turn in the conversation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$last_turn(role = "assistant")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{role}}{Role to filter by ("assistant", "user", or "system")}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A Turn object or NULL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-cost"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-cost}{}}}
\subsection{Method \code{cost()}}{
Get cost information for the conversation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$cost()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with input, output, cached, and total token costs
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-provider"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-provider}{}}}
\subsection{Method \code{provider()}}{
Get provider information.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$provider()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with provider name and model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-save_session"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-save_session}{}}}
\subsection{Method \code{save_session()}}{
Save the current session to an RDS file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$save_session(path)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{path}}{Path to save the session}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The session file contains:
\itemize{
\item Conversation turns
\item System prompt
\item Tool definitions (serialized)
\item Permissions configuration
\item Working directory
\item Metadata (timestamp, version, provider info)
}
}

\subsection{Returns}{
Invisible path
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-load_session"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-load_session}{}}}
\subsection{Method \code{load_session()}}{
Load a session from an RDS file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$load_session(path, restore_tools = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{path}}{Path to the session file}

\item{\code{restore_tools}}{If TRUE (default), restore tools from session}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Note: Hooks are NOT restored from sessions as they contain
function closures that may not serialize correctly.
}

\subsection{Returns}{
Invisible self
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-compact"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-compact}{}}}
\subsection{Method \code{compact()}}{
Compact the conversation history to reduce context size.

This method uses the LLM to generate a meaningful summary of older
conversation turns, then replaces them with the summary appended to
the system prompt. This preserves important context while reducing
token usage.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$compact(keep_last = 4, summary = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keep_last}}{Number of recent turns to keep uncompacted (default: 4)}

\item{\code{summary}}{Optional custom summary to use instead of auto-generating.
If NULL, the LLM will generate a summary focusing on key decisions,
findings, files discussed, and task progress.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The compaction process:
\enumerate{
\item Fires the PreCompact hook (can cancel or provide custom summary)
\item If no custom summary, uses LLM to summarize compacted turns
\item Appends summary to system prompt under "Previous Conversation Summary"
\item Keeps only the most recent \code{keep_last} turns
}

If LLM summarization fails (e.g., no API key), falls back to a simple
text-based summary with truncated turn contents.
}

\subsection{Returns}{
Invisible self
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-print"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-print}{}}}
\subsection{Method \code{print()}}{
Print the agent configuration.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-load_skill"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-load_skill}{}}}
\subsection{Method \code{load_skill()}}{
Load a \link{Skill} into the agent.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$load_skill(skill, allow_conflicts = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{skill}}{A \link{Skill} object or path to a skill directory.}

\item{\code{allow_conflicts}}{If FALSE (default), error on tool name conflicts.
Set TRUE to allow overwriting existing tools.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible self for chaining.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-skills"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-skills}{}}}
\subsection{Method \code{skills()}}{
Get loaded skills.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$skills()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Named list of loaded \link{Skill} objects.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-slash_commands"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-slash_commands}{}}}
\subsection{Method \code{slash_commands()}}{
Get registered slash commands.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$slash_commands()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Named list of slash command definitions
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-settings"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-settings}{}}}
\subsection{Method \code{settings()}}{
Get applied Claude-style settings.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$settings()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Settings list returned by \code{\link[=claude_settings_load]{claude_settings_load()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-load_mcp"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-load_mcp}{}}}
\subsection{Method \code{load_mcp()}}{
Load tools from MCP (Model Context Protocol) servers.

Requires the mcptools package. Issues a warning if not installed or if
tool fetching fails.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$load_mcp(config = NULL, servers = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{config}}{Path to MCP configuration file. If NULL (default), uses
the mcptools default location (\verb{~/.config/mcptools/config.json}).}

\item{\code{servers}}{Optional character vector of server names to load from.
If NULL, loads from all configured servers.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible self for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-mcp_tools"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-mcp_tools}{}}}
\subsection{Method \code{mcp_tools()}}{
Get names of loaded MCP tools.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$mcp_tools()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Character vector of MCP tool names
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-run_shiny"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-run_shiny}{}}}
\subsection{Method \code{run_shiny()}}{
Run an agentic task for use in Shiny applications with shinychat.

Returns an async content stream suitable for passing to
\code{shinychat::chat_append()}. Unlike \code{run()} and \code{run_sync()}, the
multi-turn loop is driven by ellmer's \code{stream_async()} rather than
deputy's own generator. Deputy's permissions, hooks, and tool call
limits are still enforced via the \code{on_tool_request} callback.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$run_shiny(prompt, max_tool_calls = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{prompt}}{The user message to send}

\item{\code{max_tool_calls}}{Maximum number of tool calls before stopping.
Defaults to \code{permissions$max_turns} or 25. Note this counts individual
tool call requests, not LLM turns (one turn can have multiple parallel
tool calls).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A promise that resolves when the stream is complete, suitable
for \code{shinychat::chat_append()}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
