% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agent.R
\name{Agent}
\alias{Agent}
\title{Agent R6 Class}
\description{
The main class for creating AI agents that can use tools to accomplish tasks.
Agent wraps an ellmer Chat object and adds agentic capabilities including
multi-turn execution, permission enforcement, and streaming output.
}
\section{Skill Methods}{

The following methods are added dynamically when the package loads:

\describe{
\item{\verb{$load_skill(skill)}}{Load a \link{Skill} into the agent. The \code{skill}
parameter can be a Skill object or a path to a skill directory.
Returns invisible self.}
\item{\verb{$skills()}}{Get a named list of loaded \link{Skill} objects.}
}
}

\examples{
\dontrun{
# Create an agent with file tools
agent <- Agent$new(
  chat = ellmer::chat("openai/gpt-4o"),
  tools = tools_file()
)

# Run a task with streaming output
for (event in agent$run("List files in the current directory")) {
  if (event$type == "text") cat(event$text)
}

# Or use the blocking convenience method
result <- agent$run_sync("List files")
print(result$response)
}

## ------------------------------------------------
## Method `Agent$add_hook`
## ------------------------------------------------

\dontrun{
# Add a hook to block dangerous bash commands
agent$add_hook(hook_block_dangerous_bash())

# Add a custom PreToolUse hook
agent$add_hook(HookMatcher$new(
  event = "PreToolUse",
  pattern = "^write_file$",
  callback = function(tool_name, tool_input, context) {
    cli::cli_alert_info("Writing to: {tool_input$path}")
    HookResultPreToolUse(permission = "allow")
  }
))
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{chat}}{The wrapped ellmer Chat object}

\item{\code{permissions}}{Permission policy for the agent}

\item{\code{working_dir}}{Working directory for file operations}

\item{\code{hooks}}{Hook registry for lifecycle events}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Agent-new}{\code{Agent$new()}}
\item \href{#method-Agent-run}{\code{Agent$run()}}
\item \href{#method-Agent-run_sync}{\code{Agent$run_sync()}}
\item \href{#method-Agent-register_tool}{\code{Agent$register_tool()}}
\item \href{#method-Agent-register_tools}{\code{Agent$register_tools()}}
\item \href{#method-Agent-add_hook}{\code{Agent$add_hook()}}
\item \href{#method-Agent-turns}{\code{Agent$turns()}}
\item \href{#method-Agent-last_turn}{\code{Agent$last_turn()}}
\item \href{#method-Agent-cost}{\code{Agent$cost()}}
\item \href{#method-Agent-provider}{\code{Agent$provider()}}
\item \href{#method-Agent-save_session}{\code{Agent$save_session()}}
\item \href{#method-Agent-load_session}{\code{Agent$load_session()}}
\item \href{#method-Agent-compact}{\code{Agent$compact()}}
\item \href{#method-Agent-print}{\code{Agent$print()}}
\item \href{#method-Agent-load_skill}{\code{Agent$load_skill()}}
\item \href{#method-Agent-skills}{\code{Agent$skills()}}
\item \href{#method-Agent-clone}{\code{Agent$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-new"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-new}{}}}
\subsection{Method \code{new()}}{
Create a new Agent.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$new(
  chat,
  tools = list(),
  system_prompt = NULL,
  permissions = NULL,
  working_dir = getwd()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{chat}}{An ellmer Chat object created by \code{ellmer::chat()} or
provider-specific functions like \code{ellmer::chat_openai()}.}

\item{\code{tools}}{A list of tools created with \code{ellmer::tool()}. See
\code{\link[=tools_file]{tools_file()}} and \code{\link[=tools_code]{tools_code()}} for built-in tool bundles.}

\item{\code{system_prompt}}{Optional system prompt. If provided, overrides the
chat object's existing system prompt.}

\item{\code{permissions}}{A \link{Permissions} object controlling what the agent can do.
Defaults to \code{\link[=permissions_standard]{permissions_standard()}}.}

\item{\code{working_dir}}{Working directory for file operations. Defaults to
current directory.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new \code{Agent} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-run"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-run}{}}}
\subsection{Method \code{run()}}{
Run an agentic task with streaming output.

Returns a generator that yields \link{AgentEvent} objects as the agent works.
The agent will continue until the task is complete, max_turns is reached,
or the cost limit is exceeded.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$run(task, max_turns = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task}}{The task for the agent to perform}

\item{\code{max_turns}}{Maximum number of turns (default: from permissions)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A generator yielding \link{AgentEvent} objects
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-run_sync"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-run_sync}{}}}
\subsection{Method \code{run_sync()}}{
Run an agentic task and block until completion.

Convenience wrapper around \code{run()} that collects all events and returns
an \link{AgentResult}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$run_sync(task, max_turns = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{task}}{The task for the agent to perform}

\item{\code{max_turns}}{Maximum number of turns (default: from permissions)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
An \link{AgentResult} object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-register_tool"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-register_tool}{}}}
\subsection{Method \code{register_tool()}}{
Register a tool with the agent.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$register_tool(tool)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tool}}{A tool created with \code{ellmer::tool()}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible self for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-register_tools"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-register_tools}{}}}
\subsection{Method \code{register_tools()}}{
Register multiple tools with the agent.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$register_tools(tools)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tools}}{A list of tools created with \code{ellmer::tool()}}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible self for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-add_hook"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-add_hook}{}}}
\subsection{Method \code{add_hook()}}{
Add a hook to the agent.

Hooks are called at specific points during agent execution and can
modify behavior (e.g., deny tool calls, log events).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$add_hook(hook)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{hook}}{A \link{HookMatcher} object}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisible self for chaining
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
# Add a hook to block dangerous bash commands
agent$add_hook(hook_block_dangerous_bash())

# Add a custom PreToolUse hook
agent$add_hook(HookMatcher$new(
  event = "PreToolUse",
  pattern = "^write_file$",
  callback = function(tool_name, tool_input, context) {
    cli::cli_alert_info("Writing to: {tool_input$path}")
    HookResultPreToolUse(permission = "allow")
  }
))
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-turns"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-turns}{}}}
\subsection{Method \code{turns()}}{
Get the conversation history.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$turns()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list of Turn objects
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-last_turn"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-last_turn}{}}}
\subsection{Method \code{last_turn()}}{
Get the last turn in the conversation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$last_turn(role = "assistant")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{role}}{Role to filter by ("assistant", "user", or "system")}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A Turn object or NULL
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-cost"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-cost}{}}}
\subsection{Method \code{cost()}}{
Get cost information for the conversation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$cost()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with input, output, cached, and total token costs
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-provider"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-provider}{}}}
\subsection{Method \code{provider()}}{
Get provider information.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$provider()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with provider name and model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-save_session"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-save_session}{}}}
\subsection{Method \code{save_session()}}{
Save the current session to an RDS file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$save_session(path)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{path}}{Path to save the session}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The session file contains:
\itemize{
\item Conversation turns
\item System prompt
\item Tool definitions (serialized)
\item Permissions configuration
\item Working directory
\item Metadata (timestamp, version, provider info)
}
}

\subsection{Returns}{
Invisible path
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-load_session"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-load_session}{}}}
\subsection{Method \code{load_session()}}{
Load a session from an RDS file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$load_session(path, restore_tools = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{path}}{Path to the session file}

\item{\code{restore_tools}}{If TRUE (default), restore tools from session}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Note: Hooks are NOT restored from sessions as they contain
function closures that may not serialize correctly.
}

\subsection{Returns}{
Invisible self
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-compact"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-compact}{}}}
\subsection{Method \code{compact()}}{
Compact the conversation history to reduce context size.

This method fires the PreCompact hook before compacting, allowing
hooks to save important context or perform cleanup.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$compact(keep_last = 4, summary = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keep_last}}{Number of recent turns to keep uncompacted (default: 4)}

\item{\code{summary}}{Optional custom summary to use instead of auto-generating}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Compaction replaces older turns with a summary, reducing token usage
while preserving context. The PreCompact hook fires before this happens,
receiving the turns that will be compacted.
}

\subsection{Returns}{
Invisible self
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-print"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-print}{}}}
\subsection{Method \code{print()}}{
Print the agent configuration.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-load_skill"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-load_skill}{}}}
\subsection{Method \code{load_skill()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$load_skill(skill)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-skills"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-skills}{}}}
\subsection{Method \code{skills()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$skills()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Agent-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Agent-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Agent$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
